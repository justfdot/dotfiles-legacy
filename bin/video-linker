#!/usr/bin/env python

from os import (
    listdir as os_listdir,
    symlink as os_symlink,
    linesep as os_linesep
)
from os.path import (
    join as os_path_join,
    isdir as os_path_isdir,
    isfile as os_path_isfile,
    exists as os_path_exists
)
from sys import exit as sys_exit, argv as sys_argv
from mapi.exceptions import MapiNotFoundException, MapiNetworkException
from guessit import guessit
from mapi.providers import TVDb, TMDb
from termcolor import colored
# from pprint import pprint


# Just a namespace for colored functions
class paint():

    @staticmethod
    def header(text):
        return colored(text, 'blue')

    @staticmethod
    def info(text):
        return colored(text, 'green')

    @staticmethod
    def highlight(*args):
        if len(args) > 1:
            return [colored(text, 'yellow') for text in args]
        else:
            return colored(args[0], 'yellow')


class Linker():

    # In order of frequency
    VIDEO_EXTENTIONS = ('mkv', 'm4v', 'avi', 'mp4', 'mpg')

    LINKS_DIR = '/home/justf/video-linked'
    TVDB_API_KEY = '9LZFREZNXWVXILC0'
    TMDB_API_KEY = '45ec0adac697ab86704c3530b219e6de'
    tvdb_instance = None
    tmdb_instance = None
    candidates = []

    def __init__(self, path):
        if not os_path_exists(path):
            drop('Doesn\'t look like a path')
        self.walk_through(path)

    def walk_through(self, path, linkpoint=None):
        if os_path_isdir(path):
            for subpath in os_listdir(path):
                if self.walk_through(os_path_join(path, subpath), path):
                    break
        elif os_path_isfile(path):
            metadata = self.get_metadata(path)
            if not metadata:
                return
            linkname = self.make_linkname(metadata)
            if not linkname:
                return
            return self.create_link(linkpoint or path, linkname)

    def get_metadata(self, filename):
        print(paint.header(f'{os_linesep}Processing:'), filename)
        if not filename.endswith(self.VIDEO_EXTENTIONS):
            return print(paint.info('File hasn\'t recognised as a video file'))
        return self.search(**dict(guessit(filename)))

    def get_metadata_manual(self):
        _candidates = ['movie', 'television']
        if not self.media_type == 'movie':
            _candidates = _candidates[::-1]
        self.print_candidates(_candidates)
        print("  {} default, {}uit".format(
                *paint.highlight('[RETURN]', '[q]')))
        self.media_type = self.parse_selection('Type your choice:')

        if self.media_type == 'movie':
            metadata = {'title': self.get_necessary_field('title')}
        else:
            metadata = {
                'series': self.get_necessary_field('title'),
                'season': self.get_necessary_field('season')}

        metadata['year'] = self.get_necessary_field('year')

        return metadata

    def get_necessary_field(self, field):
        _field = self.inline_prompt(paint.header(f'{field.capitalize()}:'))
        if _field:
            return _field
        else:
            print(paint.info(f'It is necessary to enter the {field}'))
            return self.get_necessary_field(field)

    def make_linkname(self, metadata):
        if self.media_type == 'movie':
            return f"[M] {metadata['title']} ({metadata['year']})"
        else:
            return (f"[T] {metadata['series']} "
                    f"(S{metadata['season'].zfill(2)}, "
                    f"{metadata['year']})")

    def create_link(self, path_to_file, linkname):
        print(paint.header('Linkname:'), linkname)
        print('  {} to confirm or {}dit the linkname'.format(
            *paint.highlight('[RETURN]', '[e]')))
        self.candidates = [linkname]
        linkname = self.parse_selection(
                'Type your choice:', paint.header('New Linkname: '))
        dest = os_path_join(self.LINKS_DIR, linkname)
        try:
            os_symlink(path_to_file, dest)
            print(paint.header('Symlink:'), dest,
                  paint.header('->'), path_to_file)
            return True
        except FileExistsError:
            return print(paint.info('File already exists. Skipping'))

    def episode(self, **kwargs):
        if not self.tvdb_instance:
            self.tvdb_instance = TVDb(api_key=self.TVDB_API_KEY)
        return self.tvdb_instance.search(series=kwargs.get('title'), **kwargs)

    def movie(self, **kwargs):
        if not self.tmdb_instance:
            self.tmdb_instance = TMDb(api_key=self.TMDB_API_KEY)
        return self.tmdb_instance.search(**kwargs)

    def inline_prompt(self, prompt):
        print(paint.header(prompt), end=u' ')
        return input()

    def inline_prefill_prompt(self, message):
        from readline import set_startup_hook, insert_text
        set_startup_hook(
            lambda: insert_text(self.candidates[0]))
        try:
            return input(message)
        finally:
            set_startup_hook()

    def print_candidates(self, candidates):
        self.candidates = []
        for i, candidate in enumerate(candidates, 1):
            _i = f'[{i}]'
            if isinstance(candidate, str):
                candidate = candidate.capitalize()
            print(f'  {paint.highlight(_i) if i == 1 else _i} {candidate}')
            self.candidates.append(candidate)
            if i == 5:
                break

    def search_again(self):
        title = self.inline_prompt('Query:')
        if not title:
            print(paint.info('It is necessary to enter the search query'))
            return self.search_again()
        search_fields = {
            'type': self.media_type,
            'title': title}
        if self.media_type == 'movie':
            search_fields['year'] = self.inline_prompt(
                    'Year (default: None):') or None
        else:
            search_fields['season'] = self.inline_prompt(
                    'Season (default: 1):') or 1
            search_fields['episode'] = 1
        return self.search(**search_fields)

    def parse_selection(self, message, prefill_prompt=False):
        selection = self.inline_prompt(message)
        if not selection and self.candidates:
            return self.candidates[0]
        elif (selection.isdigit()
                and 0 < int(selection) < len(self.candidates) + 1):
            return self.candidates[int(selection) - 1]
        elif selection in ['e', 'E']:
            if prefill_prompt:
                return self.inline_prefill_prompt(prefill_prompt)
            else:
                return self.search_again()
        elif selection in ['m', 'M']:
            return self.get_metadata_manual()
        elif selection in ['s', 'S']:
            return
        elif selection in ['q', 'Q']:
            drop('Interrupted by user')
        else:
            return self.parse_selection('Invalid choice. Try again:')

    def search(self, **params):

        self.media_type = params['type']

        search_results = getattr(self, self.media_type)(**params)

        try:
            self.print_candidates(search_results)
        except MapiNotFoundException:
            print(paint.info('Nothing found'))
            print('  {}dit query, {}anual, {}kip, {}uit'.format(
                    *paint.highlight('[e]', '[m]', '[s]', '[q]')))
        except MapiNetworkException:
            drop(paint.info('Network error: couldn\'t retrieve data'))
        else:
            print("  {} default, {}dit query, {}anual, {}kip, {}uit".format(
                    *paint.highlight('[RETURN]', '[e]', '[m]', '[s]', '[q]')))
        finally:
            return self.parse_selection('Type your choice:')


def drop(message=None, with_code=1):
    if message is not None:
        print(paint.info(message), os_linesep, '-' * len(message), sep='')
    else:
        print('-' * 5)
    print('Press', paint.highlight('[RETURN]'), 'to exit')
    input()
    sys_exit(with_code)


if __name__ == '__main__':
    sys_args = sys_argv[1:]
    if not sys_args:
        drop('No arguments given')
    elif len(sys_args) > 1:
        drop('There are too many arguments. Can\'t handle it.')
    # Let's kick it
    try:
        Linker(*sys_args)
        drop('All the things done successfully', with_code=0)
    except KeyboardInterrupt:
        drop(f'{os_linesep}Interrupted by user', with_code=130)
